# LangGraph State Management - Complete Explanation

## üìç Where is the State Defined?

The state is defined in **TWO places** in your system:

### 1. **Type Definition** (in `backend/app/workflow.py`)

```python
class EstimationGraphState(TypedDict):
    """State for the estimation workflow graph."""
    raw_requirements: Any  # ProjectRequirement
    analyzed_requirement: Any  # AnalyzedRequirement
    retrieved_epics: Any  # List[Epic]
    generated_epics: Any  # List[Epic] - now includes tasks and efforts (complete)
    final_estimation: Any  # ProjectEstimation
    validation_errors: list
    current_step: str
    retry_count: int
```

**Location**: `/Users/ebpearls/Desktop/Ai estimation/backend/app/workflow.py` (lines 20-29)

This is the **schema/type definition** that tells LangGraph what fields the state should have.

### 2. **Initial State** (in `backend/app/workflow.py`)

```python
def run_estimation_workflow(project_requirement: ProjectRequirement):
    # Build graph
    app = build_estimation_graph()
    
    # Initialize state
    initial_state = {
        "raw_requirements": project_requirement,
        "analyzed_requirement": None,
        "retrieved_epics": None,
        "generated_epics": None,  # Will contain complete epics with tasks and efforts
        "final_estimation": None,
        "validation_errors": [],
        "current_step": "initialized",
        "retry_count": 0
    }
    
    # Run workflow - state gets passed through all agents
    final_state = app.invoke(initial_state)
```

**Location**: `/Users/ebpearls/Desktop/Ai estimation/backend/app/workflow.py`

This is the **actual state object** with initial values that gets passed through the workflow.

---

## üîÑ How State Flows Through All Agents (3-Agent System)

LangGraph automatically passes the state through each agent node. Each agent:
1. **Receives** the current state as input
2. **Reads** data it needs from the state
3. **Returns** a dictionary with **updates** to merge into the state
4. LangGraph **merges** the updates into the state
5. **Passes** the updated state to the next agent

**Note:** The system now uses **3 agents** (down from 5):
- Agent 1: Analyze Requirement
- Agent 2: Retrieve Similar Epics
- Agent 3: Two-Part Processing (Part 0: Keep mandatory unchanged, Part 1: Modify retrieved, Part 2: Generate new custom epics with complete tasks + hours)

### Visual Flow

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    INITIAL STATE                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ {                                                                ‚îÇ
‚îÇ   "raw_requirements": ProjectRequirement(...),                   ‚îÇ
‚îÇ   "analyzed_requirement": None,                                  ‚îÇ
‚îÇ   "retrieved_epics": None,                                       ‚îÇ
‚îÇ   "generated_epics": None,                                       ‚îÇ
‚îÇ   "final_estimation": None,                                      ‚îÇ
‚îÇ   "validation_errors": [],                                       ‚îÇ
‚îÇ   "current_step": "initialized",                                 ‚îÇ
‚îÇ   "retry_count": 0                                               ‚îÇ
‚îÇ }                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              AGENT 1: analyze_requirement_node                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ INPUT (reads from state):                                        ‚îÇ
‚îÇ   - state["raw_requirements"]                                    ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ PROCESSING:                                                      ‚îÇ
‚îÇ   - Calls OpenAI to analyze requirements                         ‚îÇ
‚îÇ   - Creates AnalyzedRequirement object                           ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ OUTPUT (returns dictionary):                                     ‚îÇ
‚îÇ   return {                                                       ‚îÇ
‚îÇ     "analyzed_requirement": AnalyzedRequirement(...),            ‚îÇ
‚îÇ     "current_step": "analyze_requirement_complete"               ‚îÇ
‚îÇ   }                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                    LangGraph merges ‚Üì
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    STATE AFTER AGENT 1                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ {                                                                ‚îÇ
‚îÇ   "raw_requirements": ProjectRequirement(...),    ‚Üê unchanged   ‚îÇ
‚îÇ   "analyzed_requirement": AnalyzedRequirement(...), ‚Üê NEW!      ‚îÇ
‚îÇ   "retrieved_epics": None,                         ‚Üê unchanged  ‚îÇ
‚îÇ   "generated_epics": None,                                       ‚îÇ
‚îÇ   "final_estimation": None,                                      ‚îÇ
‚îÇ   "validation_errors": [],                                       ‚îÇ
‚îÇ   "current_step": "analyze_requirement_complete",  ‚Üê UPDATED!   ‚îÇ
‚îÇ   "retry_count": 0                                               ‚îÇ
‚îÇ }                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            AGENT 2: retrieve_similar_epic_node                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ INPUT (reads from state):                                        ‚îÇ
‚îÇ   - state["analyzed_requirement"]                                ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ PROCESSING:                                                      ‚îÇ
‚îÇ   - Queries vector database with analyzed requirement            ‚îÇ
‚îÇ   - Retrieves 8 mandatory + 15 similar epics                     ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ OUTPUT (returns dictionary):                                     ‚îÇ
‚îÇ   return {                                                       ‚îÇ
‚îÇ     "retrieved_epics": [Epic(...), Epic(...), ...],              ‚îÇ
‚îÇ     "current_step": "retrieve_similar_epics_complete"            ‚îÇ
‚îÇ   }                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                    LangGraph merges ‚Üì
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    STATE AFTER AGENT 2                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ {                                                                ‚îÇ
‚îÇ   "raw_requirements": ProjectRequirement(...),                   ‚îÇ
‚îÇ   "analyzed_requirement": AnalyzedRequirement(...),              ‚îÇ
‚îÇ   "retrieved_epics": [Epic(...), Epic(...), ...],  ‚Üê NEW!       ‚îÇ
‚îÇ   "generated_epics": None,                                       ‚îÇ
‚îÇ   "final_estimation": None,                                      ‚îÇ
‚îÇ   "validation_errors": [],                                       ‚îÇ
‚îÇ   "current_step": "retrieve_similar_epics_complete", ‚Üê UPDATED! ‚îÇ
‚îÇ   "retry_count": 0                                               ‚îÇ
‚îÇ }                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            AGENT 3: generate_custom_epic_node (TWO-PART)        ‚îÇ
‚îÇ  Part 0: Keep mandatory unchanged | Part 1: Modify retrieved    ‚îÇ
‚îÇ  Part 2: Generate new custom epics (all with tasks + hours)    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ INPUT (reads from state):                                        ‚îÇ
‚îÇ   - state["analyzed_requirement"]                                ‚îÇ
‚îÇ   - state["retrieved_epics"]  (8 mandatory + ~12 similar)       ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ PROCESSING:                                                      ‚îÇ
‚îÇ   Part 0: Keep 8 mandatory epics UNCHANGED                      ‚îÇ
‚îÇ   Part 1: Modify ~12 retrieved similar epics                    ‚îÇ
‚îÇ      - Keep epic/task names exactly as is                       ‚îÇ
‚îÇ      - Adapt platforms (Web App ‚Üí Flutter, etc.)                ‚îÇ
‚îÇ      - Adjust effort hours                                      ‚îÇ
‚îÇ      - Add tasks only if needed                                 ‚îÇ
‚îÇ   Part 2: Generate ~20 NEW custom epics with AI                 ‚îÇ
‚îÇ      - Domain-specific generation                               ‚îÇ
‚îÇ      - Complete tasks with efforts                              ‚îÇ
‚îÇ      - Exact deduplication                                      ‚îÇ
‚îÇ   Result: ~40 complete epics (8 + 12 + 20) ALL WITH TASKS      ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ OUTPUT (returns dictionary):                                     ‚îÇ
‚îÇ   return {                                                       ‚îÇ
‚îÇ     "generated_epics": [Epic(complete), ...],  (~40 total)      ‚îÇ
‚îÇ     "current_step": "generate_custom_epics_complete"             ‚îÇ
‚îÇ   }                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                    LangGraph merges ‚Üì
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    STATE AFTER AGENT 3                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ {                                                                ‚îÇ
‚îÇ   "raw_requirements": ProjectRequirement(...),                   ‚îÇ
‚îÇ   "analyzed_requirement": AnalyzedRequirement(...),              ‚îÇ
‚îÇ   "retrieved_epics": [Epic(...), ...],                           ‚îÇ
‚îÇ   "generated_epics": [Epic(complete), ...],      ‚Üê NEW! DONE!   ‚îÇ
‚îÇ   "final_estimation": None,                                      ‚îÇ
‚îÇ   "validation_errors": [],                                       ‚îÇ
‚îÇ   "current_step": "generate_custom_epics_complete", ‚Üê UPDATED!  ‚îÇ
‚îÇ   "retry_count": 0                                               ‚îÇ
‚îÇ }                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              HELPER: create_final_estimation_node                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ INPUT (reads from state):                                        ‚îÇ
‚îÇ   - state["raw_requirements"]                                    ‚îÇ
‚îÇ   - state["analyzed_requirement"]                                ‚îÇ
‚îÇ   - state["generated_epics"]                                     ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ PROCESSING:                                                      ‚îÇ
‚îÇ   - Aggregates all epics into ProjectEstimation                  ‚îÇ
‚îÇ   - Calculates total hours by platform                           ‚îÇ
‚îÇ   - Creates final estimation object                              ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ OUTPUT (returns dictionary):                                     ‚îÇ
‚îÇ   return {                                                       ‚îÇ
‚îÇ     "final_estimation": ProjectEstimation(...),                  ‚îÇ
‚îÇ     "current_step": "create_final_estimation_complete"           ‚îÇ
‚îÇ   }                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  VALIDATION NODE                                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ INPUT (reads from state):                                        ‚îÇ
‚îÇ   - state["final_estimation"]                                    ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ PROCESSING:                                                      ‚îÇ
‚îÇ   - Checks 8 mandatory epics present                             ‚îÇ
‚îÇ   - Validates total hours reasonable                             ‚îÇ
‚îÇ   - Checks all epics have tasks                                  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ OUTPUT (returns dictionary):                                     ‚îÇ
‚îÇ   return {                                                       ‚îÇ
‚îÇ     "validation_errors": [warnings],                             ‚îÇ
‚îÇ     "current_step": "validation_passed"                          ‚îÇ
‚îÇ   }                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    FINAL STATE (END)                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ {                                                                ‚îÇ
‚îÇ   "raw_requirements": ProjectRequirement(...),                   ‚îÇ
‚îÇ   "analyzed_requirement": AnalyzedRequirement(...),              ‚îÇ
‚îÇ   "retrieved_epics": [Epic(...), ...],                           ‚îÇ
‚îÇ   "generated_epics": [Epic(complete), ...],                      ‚îÇ
‚îÇ   "final_estimation": ProjectEstimation(...),                    ‚îÇ
‚îÇ   "validation_errors": [warnings],               ‚Üê UPDATED!     ‚îÇ
‚îÇ   "current_step": "validation_passed",           ‚Üê UPDATED!     ‚îÇ
‚îÇ   "retry_count": 0                                               ‚îÇ
‚îÇ }                                                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîç How Each Agent Accesses State

### Example from Agent 1 (Analyze Requirement)

**File**: `backend/app/agents/analyze_requirement_agent.py`

```python
def analyze_requirement_node(state: Dict[str, Any]) -> Dict[str, Any]:
    """Agent receives state as parameter."""
    
    # READ from state
    raw_requirements = state["raw_requirements"]  # ‚Üê Access state data
    
    # Do processing...
    analyzed = AnalyzedRequirement(
        project_name=raw_requirements.project_name,
        domain="utilities",
        features=[...],
        # ...
    )
    
    # RETURN updates (LangGraph will merge these into state)
    return {
        "analyzed_requirement": analyzed,  # ‚Üê Add/update this field
        "current_step": "analyze_requirement_complete"  # ‚Üê Update this field
    }
```

### Example from Agent 3 (Two-Part Processing: Modify + Generate)

**File**: `backend/app/agents/generate_custom_epic_agent.py`

```python
def generate_custom_epic_node(state: Dict[str, Any]) -> Dict[str, Any]:
    """
    Agent receives state as parameter.
    
    This two-part agent does:
    Part 0: Keep 8 mandatory epics unchanged
    Part 1: Modify ~12 retrieved similar epics
    Part 2: Generate ~20 new custom epics
    All with complete tasks and effort hours!
    """
    
    # READ from state (uses data from Agent 1 and Agent 2)
    analyzed_req = state["analyzed_requirement"]  # ‚Üê From Agent 1
    retrieved_epics = state.get("retrieved_epics", [])  # ‚Üê From Agent 2
    
    # Separate mandatory and retrieved
    mandatory_epics = [e for e in retrieved_epics if e.is_mandatory]
    similar_epics = [e for e in retrieved_epics if not e.is_mandatory]
    
    all_epics: List[Epic] = []
    
    # Part 0: Add mandatory unchanged
    for mandatory in mandatory_epics:
        all_epics.append(mandatory)
    
    # Part 1 & 2: Modify retrieved + Generate custom with AI
    # ... (comprehensive prompt to OpenAI)
    
    # Process modified retrieved epics (platforms adapted, hours adjusted)
    # Process new custom epics (complete with tasks + efforts)
    
    # RETURN updates (all ~40 epics now have complete tasks with hours!)
    return {
        "generated_epics": all_epics,  # ‚Üê ~40 complete epics (8 + 12 + 20)
        "current_step": "generate_custom_epics_complete"
    }
```

---

## üß© How LangGraph Handles State

LangGraph uses a **merge strategy** for state updates:

1. **Initial State** is created when workflow starts
2. **Each agent** returns a dictionary with updates
3. **LangGraph merges** the updates into the state:
   - New keys are added
   - Existing keys are overwritten with new values
   - Keys not mentioned in the return dict stay unchanged
4. **Updated state** is passed to the next agent

### Key Points

‚úÖ **State is SHARED** - All agents can access all state fields  
‚úÖ **State is CUMULATIVE** - Each agent adds to the state  
‚úÖ **State is TYPED** - `EstimationGraphState` defines the schema  
‚úÖ **State is AUTOMATIC** - LangGraph handles passing and merging  

---

## üìÇ File Locations Summary

| What | Where |
|------|-------|
| **State Schema** | `backend/app/workflow.py` |
| **State Initialization** | `backend/app/workflow.py` |
| **Graph Building** | `backend/app/workflow.py` |
| **Agent 1 (Analyze)** | `backend/app/agents/analyze_requirement_agent.py` |
| **Agent 2 (Retrieve)** | `backend/app/agents/retrieve_similar_epic_agent.py` |
| **Agent 3 (Two-Part: Modify + Generate)** | `backend/app/agents/generate_custom_epic_agent.py` |
| **Helper: create_final_estimation** | `backend/app/workflow.py` |
| **Helper: validate_output** | `backend/app/workflow.py` |
| **Data Models** | `backend/app/models/schemas.py` |
| **Constants (8 Mandatory Epics)** | `backend/app/core/constants.py` |
| **Mandatory Epics JSON** | `backend/app/data/mandatory_epics.json` |

---

## üéØ Key Takeaways

1. **State Definition**: `EstimationGraphState` (TypedDict) in `workflow.py`
2. **State Initialization**: `initial_state` dictionary in `run_estimation_workflow()`
3. **State Access**: Each agent receives `state: Dict[str, Any]` as parameter
4. **State Updates**: Each agent returns `Dict[str, Any]` with updates
5. **State Merging**: LangGraph automatically merges updates into state
6. **State Flow**: Passed sequentially through **3 agents** + helper nodes
7. **State Persistence**: Each agent can access data from ALL previous agents
8. **Two-Part Agent 3**: Keeps mandatory unchanged, modifies retrieved epics, generates new custom epics - all with complete tasks and hours in one pass!

**Current System: 3 Agents + 2 Helper Nodes**
- **Agent 1**: Analyze Requirement (extract structure)
- **Agent 2**: Retrieve Similar Epics (MySQL vector search, 8 mandatory + ~12 similar epics)
- **Agent 3**: Two-Part Processing (Part 0: Keep mandatory unchanged | Part 1: Modify retrieved | Part 2: Generate custom - all with complete tasks + hours, max_tokens=8000!)
- **Helper 1**: create_final_estimation_node (aggregate to ProjectEstimation)
- **Helper 2**: validate_output_node (check 8 mandatory epics + business rules)

**Recent Improvements (January 2026):**
- ‚úÖ MySQL with vector embeddings (replaced ChromaDB)
- ‚úÖ Platform filtering fix (string comparison for "Flutter", "API", etc.)
- ‚úÖ Token limit optimization (15-25 epics target, max_tokens=8000)
- ‚úÖ Platform mapping ("Web Service" ‚Üí "API", "Designer" ‚Üí "CMS")
- ‚úÖ Semantic deduplication in Agent 3
- ‚úÖ 3-tier estimation strategy (pattern matching, AI, rules)

The state acts as a **shared memory** that accumulates information as it flows through the workflow! üîÑ

---

**Last Updated**: January 12, 2026  
**Version**: 3.0 (3-Agent Architecture with MySQL & Token Optimization)
